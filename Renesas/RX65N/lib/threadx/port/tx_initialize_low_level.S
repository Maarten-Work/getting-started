;/**************************************************************************/
;/*                                                                        */
;/*       Copyright (c) Microsoft Corporation. All rights reserved.        */
;/*                                                                        */
;/*       This software is licensed under the Microsoft Software License   */
;/*       Terms for Microsoft Azure RTOS. Full text of the license can be  */
;/*       found in the LICENSE file at https://aka.ms/AzureRTOS_EULA       */
;/*       and in the root directory of this software.                      */
;/*                                                                        */
;/**************************************************************************/
;
;
;/**************************************************************************/
;/**************************************************************************/
;/**                                                                       */ 
;/** ThreadX Component                                                     */ 
;/**                                                                       */
;/**   Initialize                                                          */
;/**                                                                       */
;/**************************************************************************/
;/**************************************************************************/
;
;
;#define TX_SOURCE_CODE
;
;
;/* Include necessary system files.  */
;
;#include "tx_api.h"
;#include "tx_initialize.h"
;#include "tx_thread.h"
;#include "tx_timer.h"
;
;

.extern     __tx_initialize_unused_memory
.extern     __tx_thread_context_save
.extern     __tx_thread_context_restore
.extern     __tx_timer_interrupt
.extern     _end                               ; this label is generated by the linker
.extern     _PowerON_Reset                     ; program start label

;    /* CMT0 timer offsets & constants for RX6xx */
    
.equ    CMSTR0, 0x00088000
.equ    COUNTER_VALUE, 0x1D4C
.equ    CONTROL_VALUE, 0x41
.equ    IPR04, 0x87304


.text

;/**************************************************************************/ 
;/*                                                                        */ 
;/*  FUNCTION                                               RELEASE        */ 
;/*                                                                        */ 
;/*    _tx_initialize_low_level                            RX6xx/GNU       */ 
;/*                                                           6.0          */
;/*  AUTHOR                                                                */
;/*                                                                        */
;/*    William E. Lamie, Microsoft Corporation                             */
;/*                                                                        */
;/*  DESCRIPTION                                                           */ 
;/*                                                                        */ 
;/*    This function is responsible for any low-level processor            */ 
;/*    initialization, including setting up interrupt vectors, setting     */ 
;/*    up a periodic timer interrupt source, saving the system stack       */ 
;/*    pointer for use in ISR processing later, and finding the first      */ 
;/*    available RAM memory address for tx_application_define.             */ 
;/*                                                                        */ 
;/*  INPUT                                                                 */ 
;/*                                                                        */ 
;/*    None                                                                */ 
;/*                                                                        */ 
;/*  OUTPUT                                                                */ 
;/*                                                                        */ 
;/*    None                                                                */ 
;/*                                                                        */ 
;/*  CALLS                                                                 */ 
;/*                                                                        */ 
;/*    None                                                                */ 
;/*                                                                        */ 
;/*  CALLED BY                                                             */ 
;/*                                                                        */ 
;/*    _tx_initialize_kernel_enter           ThreadX entry function        */ 
;/*                                                                        */ 
;/*  RELEASE HISTORY                                                       */ 
;/*                                                                        */ 
;/*    DATE              NAME                      DESCRIPTION             */
;/*                                                                        */
;/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
;/*                                                                        */
;/**************************************************************************/
;VOID   _tx_initialize_low_level(VOID)
;{
.global __tx_initialize_low_level
__tx_initialize_low_level:
;
;    /* Save the first available memory address.  */
;    _tx_initialize_unused_memory =  (VOID_PTR) &free_mem_start;
;
    MOV.L    #_end, R1                ; Pickup unused memory address
    MOV.L    #__tx_initialize_unused_memory,R2                
    MOV.L    R1,[R2]                            ; Save first free memory address
;
;
;    /* Set the VBR register.  */

    MOV.L       #vector_table_start,R1
    MVTC        R1,INTB
;
;    /* Setup periodic ThreadX Timer interrupt here!  */
;    /* Set up CMT0 interrupt priority to 7 & enable in IPR08 */
    MOV.L    #IPR04, R1
    MOV.L    #7, R2
    MOV.B    R2, [R1]
         
;    /* enable CMT0/1 */
    MOV.L    #80010H,r1
    MOV.L    [r1], r2
    AND      #~(1<<15), r2
    MOV.L    r2, [r1]
 
;   /* Clear CMT0 Hardware */
    MOV.L    #0, R1
    MOV.L    #CMSTR0, R2             ; CMT0 base address
    MOV.W    R1, 2[R2]               ; clear CMCR_0
    MOV.W    R1, 4[R2]               ; clear CMCNT_0

;  /* peripheral clock is 48Mhz (default value) */

    MOV.L    #COUNTER_VALUE, R1 
    MOV.W    R1,6[R2]   
    MOV.L    #CONTROL_VALUE, R1      ; enable interrupt generation
    MOV.W    R1, 2[R2]               ; cmcr, clock select = Pclock/32/ 0x7530 for 10ms tick   
    MOV.L    #1, r1
    MOV.W    r1, [R2]                ; start counter 

;  /* enable timer interrupt IER03.IEN4 */
    MOV.L #87203H, R1
    MOV.B [r1], r2
    BSET  #4, r2
    MOV.B r2,[r1]

;    /* Done, return to caller.  */
    RTS                                    

;}
;


;/* Define the default interrupt vector. */
;
.global __tx_initialize_default_isr
__tx_initialize_default_isr:
    BRA     __tx_initialize_default_isr

;/* Define timer interrupt service routine entry point.  */
.global __tx_timer_interrupt_entry
__tx_timer_interrupt_entry:
        PUSHM R1-R2
        ;    /* acknowledge interrupt at hardware if necessary */
        BRA __tx_timer_interrupt ; branch to optimized timer handler (optimized interrupt stack: (top r2, r1, PC, PSW bottom)
;
;/* Define sample interrupt service routine.  */
;
.global __tx_initialize_sample_ISR
__tx_initialize_sample_ISR:              ; insert this label in the vector table
    PUSHM R1-R2
    BSR __tx_thread_context_save         ; Threadx RX6xx ISR prologue 

    ; Your ISR processing here!
    ; interrupts may be enabled here or anytime in the ISR with SETPSW I
    ; BSR C_function_label

    BRA __tx_thread_context_restore     ; Threadx RX6xx ISR epilogue

    
; default runtime exception handlers    
_Excep_SuperVisorInst:
   BRA _Excep_SuperVisorInst    
    
_Excep_UndefinedInst:
   BRA _Excep_UndefinedInst 
    
_Excep_FloatingPoint:
   BRA _Excep_FloatingPoint
   
_NonMaskableInterrupt:
   BRA _NonMaskableInterrupt    
;
;/* vector table, VBR is set in tx_initialize_low_level */
;   
    
.section ".vectors" , "a"
.align 4
vector_table_start:
    .fill 28, 4 , 0x0 
    .long __tx_timer_interrupt_entry
    .fill 227, 4, 0x0   
    
;
; /* fixed vectors, required at boot time */
;
    
.section ".fvectors" , "a"
.align 4
fvector_table_start:
    .long 0xFFFFFFFF 
    .long 0xFFFFFFFF 
    .long 0xFFFFFFFF 
    .long 0xFFFFFFFF 
    .long 0
    .long 0
    .long 0
    .long 0
    .long 0
    .long 0
    .long 0
    .long 0
    .long _Excep_SuperVisorInst
    .long 0
    .long 0
    .long _Excep_UndefinedInst
    .long 0
    .long _Excep_FloatingPoint
    .long 0
    .long 0
    .long 0
    .long 0
    .long _NonMaskableInterrupt
    .long _PowerON_Reset

.end
